<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>atajti.hu &#8211; r-projekt.hu</title>
	<atom:link href="/author/atajti-hu/feed/" rel="self" type="application/rss+xml" />
	<link></link>
	<description>R: az ingyenes adatelemző szoftver és statisztikai programozási környezet</description>
	<lastBuildDate>Fri, 26 Mar 2021 00:15:32 +0000</lastBuildDate>
	<language>hu</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.8.18</generator>
	<item>
		<title>useR! 1. nap</title>
		<link>/2015/07/02/user-1-nap/</link>
		<comments>/2015/07/02/user-1-nap/#comments</comments>
		<pubDate>Thu, 02 Jul 2015 08:57:42 +0000</pubDate>
		<dc:creator><![CDATA[atajti.hu]]></dc:creator>
				<category><![CDATA[Egyéb]]></category>
		<category><![CDATA[konferencia]]></category>
		<category><![CDATA[user!]]></category>
		<category><![CDATA[user2015]]></category>

		<guid isPermaLink="false">/?p=184768</guid>
		<description><![CDATA[A jelenleg is napfényes Aalborgban zajlik az idei useR! konferencia. Az első napon délelőtt és délután is négy-négy tutorial közül válogathattak a résztvevők. Én (a többi magyar résztvevővel együtt) Csárdi Gábor Igraph-bemutatójára ültem be: a legfrissebb (1.0) verzóban már valósággal &#8230; <a href="/2015/07/02/user-1-nap/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>A jelenleg is napfényes Aalborgban zajlik az idei useR! konferencia.</p>
<p><span id="more-184768"></span></p>
<p>Az első napon délelőtt és délután is négy-négy tutorial közül válogathattak a<br />
résztvevők. Én (a többi magyar résztvevővel együtt) Csárdi Gábor Igraph-bemutatójára ültem be: a legfrissebb (1.0) verzóban már valósággal lubickolni lehet a különböző gráfmanipulálási módszerekben, szintaxisokban: a régiek (egyelőre) megmaradnak, viszont az egész bővült egy make_* függvénycsaláddal, ráadásul a make_ önmagában is megáll függvényként. Amióta utoljára elmélyültem a csomagban, jelentősen fejlődött az ábrázolás, lehet közösségeket is plottolni követlenül, nem kell a csúcsok attribútumait beállítani. Viszont lehet használni meglepően nagy mértékben: a csúcsok (vagy élek) attribútumaként is meg lehet adni a paramétereket (szín, alak, méret, bármi ami létezik). Hozzá lehet nyulni a gráf elemeihez már a &#8220;[&#8221; es &#8220;[[&#8221; operátorokkal is. Ami szintén egy nagy újítás számomra, hogy össze lehet hasonlítani a közösségeket a csomagban implementált függvényekkel, és nem kell külső csomagokból importálni a mérőeszközöket.</p>
<p>Délután az assertive és a testthat csomagokba kaptam egy kis bevezetőt: a két részre osztott gyakorlat első fele az előbbi, második az utóbbi csomagról szólt, hasonló felépítésben: a több mint egy órás szakaszok eleján egy bevezetőt mondott Richard J. Cotton, majd egy nagy adag házifeladaton kellett átrágni magunkat. Nem volt szó a testthat csomagnak a frissen elmentett függvényre való futtatásáról, amit Otti Levente mutatott az április BURN meetupon.</p>
<p>Este hétkor a helyi MüPában tartott a polgármester egy rövid beszédet, majd egy állófogadással ért véget a hivatalos program.</p>
<p>Via:: <a title="useR! 1. nap" href="http://atajti.hu/hu/blag/hu/user-1-nap" target="_blank">useR! 1. nap</a></p>
]]></content:encoded>
			<wfw:commentRss>/2015/07/02/user-1-nap/feed/</wfw:commentRss>
		<slash:comments>633</slash:comments>
		</item>
		<item>
		<title>Programozó programot programozni</title>
		<link>/2014/09/06/programozo-programot-programozni/</link>
		<pubDate>Sat, 06 Sep 2014 19:11:34 +0000</pubDate>
		<dc:creator><![CDATA[atajti.hu]]></dc:creator>
				<category><![CDATA[Egyéb]]></category>

		<guid isPermaLink="false">/?p=484</guid>
		<description><![CDATA[Arra gondoltam, jó volna, ha a sok, hasonló paraméterrel rendelkező függvényemet egyszerre elindíthatnám ugyanazon az adatsoron, például így: [crayon-61ed3859d4766128255338/] Először is érdemes udni, hogyan hívok meg egy függvényt, amit egy változóban kapok meg, egy olyan argumentummal, amit egy másikban. Példaként &#8230; <a href="/2014/09/06/programozo-programot-programozni/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>Arra gondoltam, jó volna, ha a sok, hasonló paraméterrel rendelkező függvényemet egyszerre elindíthatnám ugyanazon az adatsoron, például így:</p>
<p><span id="more-484"></span></p><pre class="crayon-plain-tag">eredmény függvények=c("függvény_1", "függvény_2", "függvény_n"),
közös_argumentum=változó_1,
függvény_1_argumentuma=változó_2,
függvény_v_argumentuma=változó_4)</pre><p>Először is érdemes udni, hogyan <cite>hívok meg</cite> egy függvényt, amit egy változóban kapok meg, egy olyan argumentummal, amit egy másikban. Példaként vegyűk az R beépített <cite>iris</cite> adatbázisát:</p><pre class="crayon-plain-tag"># Előkészítem a függvényt és a változót:
f1 &lt;- "mean"
v1
# a változókban tárolt feladatot elvégeztetem:
do.call(f1, list(x=v1))
# 5.843333</pre><p>A <cite>do.call</cite> függvény egy karakterként kéri a függvény nevét, és egy elnevezett listában kéri az argumentumokat. Ezek alapján, ha egyszerre több függvényt szeretnénk meghívni, használhatjuk a megszokott <cite>*apply</cite> függvénycsaládot:</p><pre class="crayon-plain-tag"># több függvényt hívok egyszerre majd meg:
f2
v1
# sapply-jal minden függvényre megcsinálom a do.call-t
sapply(f2, do.call, args=list(x=v1))
# mean sum
# 5.843333 876.500000</pre><p>Megoldható az is, hogyha az <cite>iris</cite> adatok mindegyikén (legalábbis a számokon) szeretném elvégezni a feladatot, ugyanakkor az sapply erre már nem jó:</p><pre class="crayon-plain-tag"># változók:
f2
# az iris oszlopnevei, az 5-ik kivételével. paste(), hogy eléjük tegyem a data.frame nevét:
v2
# sapply
sapply(v2, function(v){sapply(f2, do.call, args=list(x=v))})</pre><p>A probléma, hogy ebben az esetben az &#8220;isir$Sepal.Length&#8221; sztringre próbálja elvégezni az átlagszámítást, ami természetesen nem megy. (Egyébként próbálkoztam névvé alakítani, abban az esetben nem találja meg, és még nem tudom hogy miért). Érdemes tehát kicsit belevetni magunkat abba, hogyan íratunk meg az R-rel olyan kódokat, amiket később végre tud hajtani.</p>
<p>Ehhez azt kell tudnom, hogy fog kinézni a <cite>kifejezés (expression)</cite>:</p><pre class="crayon-plain-tag">sapply([függvények], do.call, args=list(x=[változó]))</pre><p>A <strong>[függvények]</strong> helyére a függvények neveit tartalmazó karakter vektor neve (esetemben f2), a <strong>[változó]</strong> helyére pedig az egyes oszlopok nevei kell kerüljenek. Először érdemes összerakni ezt a kifejezést:</p><pre class="crayon-plain-tag">paste0("sapply(f2, do.call, args=list(x=", [változó neve], "))")</pre><p>Ebben a kódban már csak a változó nevét kell cserélgetni, amire viszont teljesen jó az <cite>sapply</cite>:</p><pre class="crayon-plain-tag">ch1 &lt;- sapply(v2, function(v){paste0("sapply(f2, do.call, args=list(x=", v, "))")})
str(ch1)</pre><p>A ch1 a kód végrehajtása után egy karakter vektor lesz, minden egyes elemének van neve, és tartalma a kód, ami egy érvényes kifejezés (lesz, most még csak egy betűhalom), és az R végre fogja tudni hajtani mindet, ha tudja, hogy értelmeznie kell őket. Az értelmezést a <cite>parse</cite> függvény, a végrehajtást pedig az <cite>eval</cite> függvény végzi. Előbbinél figyelni kell, hogy egy sztring megadása a <cite>text</cite> paraméterbe kell kerüljön, különben egy fájl tartalmát fogja keresni. Tehát a</p><pre class="crayon-plain-tag">eval(parse(text=ch1[1]))</pre><p>parancs során az R megajándékoz két, névvel ellátott számmal, azt sem kell kitalálni, melyiket melyik függvény eredményeként kaptam (ez a képesség engem nagyon kellemes meglepetésként ért). Tehát nem maradt más hátra, mint előre, és az <cite>eval(parse())</cite> kombinációt a <cite>ch1</cite> minden tajára elvégezni:</p><pre class="crayon-plain-tag">eredmeny
str(eredmeny)</pre><p>Teljes siker: kaptunk egy függvény és egy változólistát (<cite>f2</cite> és <cite>v2</cite>), és azt megcsináltuk azok konkrét mivoltának ismerete nélkül. Ráadásként pedig egy szépen strukturált eredményt kaptunk: egy mátrixot, annak oszlopaiban a változónevekkel, soraiban pedig a függényekkel. Ez az <cite>sapply</cite> egyik argumentumának és alapbeállításának köszönhető (<cite>simplify=TRUE</cite>), ami, ha azonos típusúak az egyes függvények eredményei, összecsomagolja őket egy vektorba/mátrixba/tömbbe, ha pedig egyikbe sem tudja, akkor listaként adja vissza az eredményt. Ennek természetesen vannak veszélyei, de ilyen egyszerű feladatnál ezt még biztos tudja kezelni az R (érdemes kipróbálni, mi történik, ha a szórás kiszámítása helyett karakterré alakítjuk a számokat &#8211; ez nem csak típusban, hanem hosszban is eltérő eredményeket fog ugyanis adni. Egyúttal itt a kérdés is, amire még nem tudom a magyarázatot: hogyan sikerül az eredményt mátrixszá összegyúrnia az sapply-nak?)</p>
<p>Az <cite>iris</cite> adatok tartalmazzák az egyes példányok fajtáját is, a következő(nek szánt) bejegyzésben azt részletezem majd, hogyan lehet minden fajtára elvégezni a kívánt műveleteket (lehetőleg gyorsan), illetve hogyan lehet bonyolultabb függvényeket, amik több argumentummal is rendelkeznek, ellátni a szükséges információkkal.</p>
<p>Via: <a title="Programozó programot programozni" href="http://atajti.hu/hu/blag/hu/programoz%C3%B3-programot-programozni" target="_blank">Programozó programot programozni</a></p>
]]></content:encoded>
			</item>
		<item>
		<title>Szenvedés az ékezetekkel &#8211; személyes feljegyzés</title>
		<link>/2014/07/30/szenvedes-az-ekezetekkel-szemelyes-feljegyzes/</link>
		<pubDate>Tue, 29 Jul 2014 23:29:02 +0000</pubDate>
		<dc:creator><![CDATA[atajti.hu]]></dc:creator>
				<category><![CDATA[Egyéb]]></category>

		<guid isPermaLink="false">/?p=424</guid>
		<description><![CDATA[Kitaláltam, hogy habár nem illik a megszokotthoz, csakazértis R-rel készítem el a jelentés ábráit, egyszerűen mert unalmas az Excelben rajzolgatni őket, túl szőrözős. Ráadásul itt kell hagynom a munkahelyemen a tudást és nem fogok emlékezni rá, így feljegyzem. A probléma &#8230; <a href="/2014/07/30/szenvedes-az-ekezetekkel-szemelyes-feljegyzes/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>Kitaláltam, hogy habár nem illik a megszokotthoz, csakazértis R-rel készítem el a jelentés ábráit, egyszerűen mert unalmas az Excelben rajzolgatni őket, túl szőrözős. Ráadásul itt kell hagynom a munkahelyemen a tudást és nem fogok emlékezni rá, így feljegyzem.</p>
<p>A probléma az, hogy habár egy R markdown dokumentumot, amíg csak szöveg van benne, szépen át tudok tenni Word-be a Knitr segítségével, mindez a képeknél nem működik. Ha grafikont rajzolok, a feliratok rosszul jelennek meg, például &#8220;é&#8221; helyett azt látom, hogy &#8220;ˇA©&#8221;. Márpedig így nem lesz olvasható az ábra, és csinálhatom meg mégis inkább Excellel. A markdown fájl jó, az R jó, mert ha csak az ablakra rakom ki, működik. Az ábrát a Knitr csinálja, tehát valószínűleg nála lesz a probléma.</p>
<p><span id="more-424"></span></p>
<p>A cirill karakterekre panaszkodtak sokan, így hosszú kutató munka, az R kódolásának, a forrás kódolásának, a locale átállításának kipróbálása után megtaláltam <a href="http://yihui.name/knitr/demo/graphics/" target="_blank">Yihui vonatkozó posztját</a>, és a bug-reportokat is. Ezek egyrészt a <pre class="crayon-plain-tag">pdf.options(encoding)</pre>  megfelelő beállítását hangsúlyozták, illetve egy külön beállítás létrehozását az ablakokra. Eddig ezekkel nem jutottam dűlőre.</p>
<p>Máshol a karakterkészletet hibáztatják, ugyanakkor nem gondolom, hogy itt is az lenne a probléma. Lehet, hogy azt a köztes utat választom majd, hogy elmentem az ábrákat én magam a <pre class="crayon-plain-tag">png()</pre>  paranccsal, bár ez lehet, hogy meg fogja zavarni a Knitr munkáját. Holnap kiderül!</p>
<hr />
<p>Ki is derült: nem tudom miért nem működött tegnap, de ma sikeresen vette az ékezeteket: egyrészt a <pre class="crayon-plain-tag">knit2html()</pre>  függvénynek meg kell adni, hogy UTF-8-ban kódoljon <cite>(<pre class="crayon-plain-tag">encoding="UTF-8"</pre> )</cite>, az R az magyarra volt lokalizálva, a forráskód pedig szintén UTF-8. Ezt a konfigurációt egyébként kipróbáltam tegnap, de ma legalább működik.</p>
<p>Via: <a title="Szenvedés az ékezetekkel - személyes feljegyzés" href="http://atajti.hu/hu/blag/hu/szenved%C3%A9s-az-%C3%A9kezetekkel-szem%C3%A9lyes-feljegyz%C3%A9s" target="_blank">Szenvedés az ékezetekkel &#8211; személyes feljegyzés</a></p>
]]></content:encoded>
			</item>
		<item>
		<title>data.table vs. knitr</title>
		<link>/2014/07/17/data-table-vs-knitr/</link>
		<pubDate>Thu, 17 Jul 2014 19:18:42 +0000</pubDate>
		<dc:creator><![CDATA[atajti.hu]]></dc:creator>
				<category><![CDATA[Egyéb]]></category>

		<guid isPermaLink="false">/?p=417</guid>
		<description><![CDATA[Egy elég hosszúra nyúlt hibakeresési folyamat végén találtam rá arra, ami talán másokat is igen erősen érinthet, akik a data.table csomag segítségével tartják kordában (illetve memóriában) az adatokat, aztán a knitr segítségével próbálnak jelentést generálni. A knitr nem figyel fel &#8230; <a href="/2014/07/17/data-table-vs-knitr/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>Egy elég hosszúra nyúlt <a href="http://atajti.hu/hu/blag/hu/hibakeres%C3%A9s-gy%C3%B6ny%C3%B6r%C5%B1s%C3%A9ge" target="_blank">hibakeresési folyamat</a> végén találtam rá arra, ami talán másokat is igen erősen érinthet, akik a <cite>data.table</cite> csomag segítségével tartják kordában (illetve memóriában) az adatokat, aztán a <cite>knitr</cite> segítségével próbálnak jelentést generálni.</p>
<p><span id="more-417"></span></p>
<p>A knitr nem figyel fel a <pre class="crayon-plain-tag">data.table::set()</pre>  függvényt helyettesítő <pre class="crayon-plain-tag">:=</pre>  operátorra, ami miatt az épp így módosított táblázatot teljes egészében beleírja a dokumentumba. Mivel ez nem túl kívánatos, a megoldás az, hogy minden egyes ilyen műveletnél rendeljük hozzá a táblázat saját nevét:</p><pre class="crayon-plain-tag">DT[, a:=sum(b)] helyett DT &lt;- DT[, a:=sum(b)]</pre><p>Ilyen módon a memóriafogyasztás illetve a sebesség sem csorbul jelentősen, viszont nem kell százoldalas táblázatokat nézegetnünk.</p>
<p>További olvasmányok a témárór a Stack Owerflow-n angolul: <a href="http://stackoverflow.com/questions/15267018/knitr-gets-tricked-by-data-table-assignment" target="_blank">felületesebben</a> és <a href="http://stackoverflow.com/questions/15298359/why-does-knitr-caching-fail-for-data-table" target="_blank">részletesebben</a>.</p>
<p>Via: <a title="data.table vs. knitr" href="http://atajti.hu/hu/blag/hu/datatable-vs-knitr" target="_blank">data.table vs. knitr</a></p>
]]></content:encoded>
			</item>
		<item>
		<title>Így készíts docx fájlt R-rel!</title>
		<link>/2014/06/25/igy-keszits-docx-fajlt-r-rel-2/</link>
		<pubDate>Wed, 25 Jun 2014 16:08:33 +0000</pubDate>
		<dc:creator><![CDATA[atajti.hu]]></dc:creator>
				<category><![CDATA[Egyéb]]></category>

		<guid isPermaLink="false">/?p=378</guid>
		<description><![CDATA[Sikerült R-rel olyan jelentést készítenem, amit utólag tudok szerkesztgetni Wordben. Hogy ez miért nagy szám? Mert egyben megírhatom a kódot, meg közérakhatom a fejezetcímeket, és így tulajdonképpen készen lehetnek az ábrák amikről csak írnom kell, ha szeretnék, oldalakat. De ha &#8230; <a href="/2014/06/25/igy-keszits-docx-fajlt-r-rel-2/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>Sikerült R-rel olyan jelentést készítenem, amit utólag tudok szerkesztgetni Wordben. Hogy ez miért nagy szám? Mert egyben megírhatom a kódot, meg közérakhatom a fejezetcímeket, és így tulajdonképpen készen lehetnek az ábrák amikről csak írnom kell, ha szeretnék, oldalakat. De ha nagyon ismerem az anyagot, akár ott helyben, R-kódok között megírhatom a jelentést.<br />
Ez alapvetően nem annyira nagy dolog, hiszen a <a href="http://rapporter.net/" target="_blank">Rapporter</a> már régóta csinál ilyet.</p>
<p><span id="more-378"></span></p>
<p>Én először csak véletlenül akadtam <a href="http://www.r-statistics.com/2013/03/write-ms-word-document-using-r-with-as-little-overhead-as-possible/" target="_blank">Tal Galili blogján a leírásra</a>, és bevallom, nem is teljesen értem a mögöttes rendszerek működését. Hogy mit és pontossan hogy csinál a <em>pandoc</em>? Hogy miket jelentenek a <em>knitr</em> csomag beállításai? Fogalmam sincs. Viszont a magam dolgának megkönnyítése végett az ott leírt folyamat köré írtam egy függvényt, ezt most leírom, hogy működik (ami nem nagy dolog, nagyjából megegyezik azzal, amit a hivatkozott bejegyzésben Tal is leírt).</p>
<p><strong>1.: R-ben telepítsd a <em>pander</em> csomagot, ami minden más szükséges csomagot telepíttetni fog.</strong></p>
<p></p><pre class="crayon-plain-tag">install.packages(&quot;pander&quot;)</pre><p></p>
<p><strong>2.: Telepítds a pandoc nevű programot. Ennek kétféle módja van:</strong></p>
<p><em><strong>2a.: R-ből az installr csomag segítségével</strong></em></p>
<p></p><pre class="crayon-plain-tag"># intallr csomag telep&iacute;t&eacute;se, ha kell:
if(!require(installr)) { install.packages(&quot;installr&quot;)}
# installr bet&ouml;lt&eacute;se:
require(installr)
# pandoc telep&iacute;t&eacute;se
install.pandoc()</pre><p></p>
<p>Ennek a módszernek az a hátránya, hogy nekem nem működött sehogysem az install.pandoc(). Ezért megpróbáltam natúr, magamtól telepíteni.</p>
<p><em><strong>2b.: Telepítés önmagában:</strong></em></p>
<p>A pandoc <a target="_blank">elérhető a Github-on</a>, letöltöd, majd futtatod az msi fájlt, telepítés után pedig</p>
<p><strong>3. Indítsd újra a gépet! </strong></p>
<p>Ez fontos, e nélkül a pandoc nem fog rendesen működni (valószínűleg. De lehet, hogy igen).<br />
Ezzel tulajdonképp megvannak az alapok.</p>
<p><strong>4. Írd meg, amit szerkeszteni szeretnél utána</strong></p>
<p>A <a href="http://en.wikipedia.org/wiki/Markdown" target="_blank">markdown</a> alapszabályai szerint, illetve <a href="http://rmarkdown.rstudio.com/" target="_blank">R markdownban</a>. Nem bonyolultak az alapok, érdemes utánanézni. Miután pedig kész, elmented, és megjegyzed hogy hol és milyen néven van a fájl.</p>
<p><strong>5.: rmd2docx(source)</strong></p>
<p>Innentől jön az általam egy parancsba gyógyított eljárás, ami a következőképp néz ki:<br />
(A source helyére természetesen nem mást, mint a korábban elmentett markdown fájl helyét és nevét (teljes fájlnév, elérési út) kell beírni két idézőjel közé, entert nyomni, és már hasít is a gép)</p>
<p><strong>5a.:</strong> Először beállítja a megadott fájl mappáját munkakönyvtárnak (ez később lehet, hogy problémát fog okozni, egyelőre kézenfekvőnek tűnik), aztán megkeresi a fájlnevet, majd külön a kiterjesztést, hogy megnézi, rmd fájl-e a bemenet. Mivel a kiterjesztés nem jelent semmit, ezért csak üzenet a usernek, lehet hogy lefelejtette:</p>
<p></p><pre class="crayon-plain-tag">setwd(dirname(source))
FILE &lt;- basename(source)
NAME &lt;- strsplit(FILE, &quot;.&quot;, fixed=TRUE)[[1]][1]
ext &lt;- strsplit(FILE, &quot;.&quot;, fixed=TRUE)[[1]][2]
if(!(tolower(ext)==&quot;rmd&quot;)){
message(&quot;Are you sure you use an R markdown file?&quot;)
}</pre><p></p>
<p><strong>5b.:</strong> Beolvassa a megadott fájlt, az elejéhez hozzáfűzi a megadott beállításokat, majd egy ideiglenes fájlba elmenti.</p>
<p></p><pre class="crayon-plain-tag">opts.for.docx &lt;- '```{r set_knitr_chunk_options}
opts_chunk$set(echo=FALSE,message=FALSE,results = &quot;asis&quot;) # important for making sure the output will be well formatted.
```
```{r load_pander_methods}
require(pander)
replace.print.methods &lt;- function(PKG_name = &quot;pander&quot;) {
PKG_methods &lt;- as.character(methods(PKG_name))
print_methods &lt;- gsub(PKG_name, &quot;print&quot;, PKG_methods)
for(i in seq_along(PKG_methods)) {
f &lt;- eval(parse(text=paste(PKG_name,&quot;:::&quot;, PKG_methods[i], sep = &quot;&quot;))) # the new function to use for print
assign(print_methods[i], f, &quot;.GlobalEnv&quot;)
}
}
replace.print.methods()
## The following might work with some tweaks:
## print &lt;- function (x, ...) UseMethod(&quot;pander&quot;)
```'
# append them to the file:
tempfile &lt;- readLines(FILE)
tempfile &lt;- c(opts.for.docx, tempfile)
writeLines(tempfile, &quot;tempfile.rmd&quot;)</pre><p></p>
<p><strong>5c.:</strong> Betölti a knitr csomagot, majd előbb hagyományos markdown fájlt készít belőle (feldolgozza az R kódokat), aztán összerak belőlük egy html fájlt:</p>
<p></p><pre class="crayon-plain-tag">require(&quot;knitr&quot;, quietly=TRUE)
knit2html(&quot;tempfile.rmd&quot;)</pre><p></p>
<p>Eddig ezt csak ábrák nélküli dokumentummal próbáltam. Érdemes lenne létrehozatni az R-rel egy mappát, hogy abba mentse, amit aztán egy az egyben lehetne törölni, mint szemetet, miután kész. Ez a jövő zenéje még.</p>
<p><strong>5d.:</strong> Miután megvan a markdown fájl, a pandoc-kal készíttetünk belőle a word által olvasható fájlt:</p>
<p></p><pre class="crayon-plain-tag">system(paste0(&quot;pandoc -o &quot;, NAME, &quot;.docx &quot;, &quot;tempfile&quot;, &quot;.md&quot;))</pre><p></p>
<p>A második argumentuma a paste0() függvénynek nem más, mint az eredeti rmd fájl neve, így név alapján könnyen megtaláljuk majd az új fájlt, illetve külöböző fájlok nem fogják egymást felülírni.</p>
<p><strong>5e.:</strong> Ezután pedig töröljük a korábban létrehozott markdown és html fájlokat:</p>
<p></p><pre class="crayon-plain-tag">unlink(c(&quot;tempfile.html&quot;, &quot;tempfile.md&quot;))</pre><p></p>
<p>És fel is takarítottunk magunk után, az eredeti fájl mellett ott virít büszkén a Worddel szerkeszthető doksi, benne az alap formázásnak megfelelő kínézetű, stílusokkal rendelkező szöveg, táblázatok, képek, sikeresen megoldottuk a feladatot. o/</p>
<p>A kód egészében természetesen <a href="https://github.com/atajti/miscR/blob/master/rmd2docx.r" target="_blank">elérhető GitHub-on</a>!</p>
<p>Via: <a title="Így készíts docx fájlt R-rel!" href="http://atajti.hu/hu/blag/hu/%C3%ADgy-k%C3%A9sz%C3%ADts-docx-f%C3%A1jlt-r-rel" target="_blank">Így készíts docx fájlt R-rel!</a></p>
]]></content:encoded>
			</item>
		<item>
		<title>Postacím koordinátáinak megtalálása R-rel.</title>
		<link>/2013/09/17/postacim-koordinatainak-megtalalasa-r-rel/</link>
		<comments>/2013/09/17/postacim-koordinatainak-megtalalasa-r-rel/#comments</comments>
		<pubDate>Tue, 17 Sep 2013 09:55:13 +0000</pubDate>
		<dc:creator><![CDATA[atajti.hu]]></dc:creator>
				<category><![CDATA[Egyéb]]></category>
		<category><![CDATA[cím]]></category>
		<category><![CDATA[geokódolás]]></category>
		<category><![CDATA[tér]]></category>

		<guid isPermaLink="false">/?p=180</guid>
		<description><![CDATA[Nemrég írtam egy függvényt R-ben, aminek meg kell adni egy címet sztringként, és rákeres GoogleMaps-en, majd visszaadja a szélességi és hosszúsági fokokat. Alább a kód, ami GitHub-on is megtalálható. FONTOS: a működéshez szükséges az rjson csomag (valószínűleg az RJSONIO is &#8230; <a href="/2013/09/17/postacim-koordinatainak-megtalalasa-r-rel/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>Nemrég írtam egy függvényt R-ben, aminek meg kell adni egy címet sztringként, és rákeres GoogleMaps-en, majd visszaadja a szélességi és hosszúsági fokokat.<span id="more-180"></span></p>
<div>
<p>Alább a kód, ami <a href="https://github.com/atajti/miscR/blob/master/getAddressCoord.r" target="_blank">GitHub</a>-on is megtalálható.</p>
<p>FONTOS: a működéshez szükséges az rjson csomag (valószínűleg az RJSONIO is jó).</p><pre class="crayon-plain-tag">[crayon-61ed3859d5a0b888231396 inline=&quot;true&quot; ]getAddressCoord &amp;lt;- function(address){
address &amp;lt;- as.character(address)
address &amp;lt;- paste(unlist(strsplit(address, split=&quot; &quot;)), collapse=&quot;+&quot;)
base &amp;lt;- &quot;http://maps.googleapis.com/maps/api/geocode/json?address=&quot;
ending &amp;lt;- &quot;&amp;amp;sensor=false&quot;
download.file(url=paste(base, address, ending, sep=&quot;&quot;),
destfile=&quot;temp_address_info.json&quot;)
address.info &amp;lt;- fromJSON(file=&quot;temp_address_info.json&quot;)
unlink(&quot;temp_address_info.json&quot;)
if(address.info[[&quot;status&quot;]] == &quot;OK&quot;){
long.lat &amp;lt;- unlist(address.info$results[[1]]$geometry$location)
return(long.lat)
} else {
return(&quot;Result is not appropriate!&quot;)
}
}</pre><p>[/crayon]
</p></div>
<p>Via: <a title="Postacím koordinátáinak megtalálása R-rel." href="http://atajti.hu/hu/blag/hu/postac%C3%ADm-koordin%C3%A1t%C3%A1inak-megtal%C3%A1l%C3%A1sa-r-rel" target="_blank">Postacím koordinátáinak megtalálása R-rel.</a></p>
]]></content:encoded>
			<wfw:commentRss>/2013/09/17/postacim-koordinatainak-megtalalasa-r-rel/feed/</wfw:commentRss>
		<slash:comments>533</slash:comments>
		</item>
		<item>
		<title>64 bites számok R-ben</title>
		<link>/2013/05/15/64-bites-szamok-r-ben/</link>
		<comments>/2013/05/15/64-bites-szamok-r-ben/#comments</comments>
		<pubDate>Wed, 15 May 2013 01:31:56 +0000</pubDate>
		<dc:creator><![CDATA[atajti.hu]]></dc:creator>
				<category><![CDATA[Egyéb]]></category>

		<guid isPermaLink="false">/?p=181</guid>
		<description><![CDATA[Az érdekes problémák érdekes tanulságokhoz vezetnek. Kiindulás: írtam egy modellt, amiben használok UNIX időbélyegeket az időpontok megjelölésére. Ebben nincs semmi ördöngősség, egy szám, ami az 1970 január 1. óta eltelt másodpercek segítségével jelzi az időt. A helyzet azonban az, hogy &#8230; <a href="/2013/05/15/64-bites-szamok-r-ben/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>Az érdekes problémák érdekes tanulságokhoz vezetnek.</p>
<p>Kiindulás: írtam egy modellt, amiben használok UNIX időbélyegeket az időpontok megjelölésére. Ebben nincs semmi ördöngősség, egy szám, ami az 1970 január 1. óta eltelt másodpercek segítségével jelzi az időt. A helyzet azonban az, hogy ezek nagy számok, annyira nagyok, hogy egy átlagos számítógép nem nagyon tud vele mit kezdeni, nem fér el a szokásos 32 biten, mert azon csak 2^32-1 számot tudnak megmutatni. Erre készítettek egy csomagot, ami úgy ábrázolja a 64 bites számokat, hogy az első 32-t és a második 32-t külön veszi, és egy listaként tartja számon. Bravúros megoldás, és rettentően jól működött, míg csak tárolni kellett. A használata már nehezebb volt.<span id="more-181"></span></p>
<p>Amikor egyenletes mintát szerettem volna venni a rendelkezésre álló időintervallumból, elsőre azt kértem, válasszon ki véletlenül n darab számot 1és N közül, ahol N&gt;2^31-1. Erre hibát adott, de én furfangos vagyok, és kértem n darab véletlen számot 0 és 1 közül, majd beszoroztam N-nel &#8211; de ezek eredménye mind 0, mert véletlenszám 64 bitesre konvertálása során a törtszámok egészig csonkolódnak. Ennek oka, hogy a csomag először a másik, nem 64bites számot is átkonvertálja ugyan olyanra, mint az eredeti &#8211; ami viszont egészekre van kitalálva, tehát az átkonvertált számnak is egésznek kell majd lennie. Erre van ám egyszerű megoldás, vegyünk 1 és 2^31-1 közt egyenletesen mintát. Ekkor a lehetséges számok intervallumának felét fedtük le. Ha ezt felszoroznánk kettővel, akkor vennénk a teljes intervallumról&#8230; de nem, mert az csak 2^32-1ig menne. De az ötlet nem rossz, vegyünk nagy egész számokat, amíg a szükséges minta nem nagyobb a meglévő számoknál, és osszuk el azokat a számokat egyenletesen 1 és N közt!<br />
-No, hát melyik legyen ez a szám?<br />
-2^31-1!<br />
-Nem jó! Az R nem tud ilyen hosszú vektort lefoglalni. Pech, jöhet az alternatíva-keresés az időbélyegek helyett&#8230;</p>
<p>No, sebaj, az R 3.0.0 már ismeri a 2^31-1 elemnél hosszabb vektorokat, de csak 64 bites rendszeren. Hmmmm&#8230; öcsém alszik, és a vasa megfelel a kritériumnak. Essünk neki.<br />
Nem, nem működött (természetesen). A számokkal sem boldogult el, ráadásul a használt csomagok (az hagyján hogy int64, de a plyr és a doParallel) még híján vannak a friss verzióhoz tartozó változatnak, így azzal kváti semmit nem tudtam kezdeni laikusként. Pedig de szép is lett volna!</p>
<p>A megoldás<br />
A bit64 csomag, és annak a megoldásai. Zseniálisan egyszerű lett tőle a dolgom <img src="https://s.w.org/images/core/emoji/2.3/72x72/1f642.png" alt="&#x1f642;" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>
<p>Via: <a title="64 bites számok R-ben" href="http://atajti.hu/hu/content/64-bites-sz%C3%A1mok-r-ben" target="_blank">64 bites számok R-ben</a></p>
]]></content:encoded>
			<wfw:commentRss>/2013/05/15/64-bites-szamok-r-ben/feed/</wfw:commentRss>
		<slash:comments>554</slash:comments>
		</item>
		<item>
		<title>Elkezdtem a Pythont</title>
		<link>/2013/04/13/elkezdtem-a-pythont/</link>
		<comments>/2013/04/13/elkezdtem-a-pythont/#comments</comments>
		<pubDate>Sat, 13 Apr 2013 18:46:44 +0000</pubDate>
		<dc:creator><![CDATA[atajti.hu]]></dc:creator>
				<category><![CDATA[Egyéb]]></category>

		<guid isPermaLink="false">/?p=182</guid>
		<description><![CDATA[Viszonylag gyakorlott R felhasználónak tartom magam. Szeretem, mert közelebb áll az MS Excelhez, amit előtte kellett használnom, illetve követekezetesebb, egyértelműbb, kezelhetőbb, gyorsabb mint az SPSS Syntax-sza. Sok helyütt olvastam már a Pythonról, de sosem próbáltam ki, mert csak zagyva bevezetőket &#8230; <a href="/2013/04/13/elkezdtem-a-pythont/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>Viszonylag gyakorlott R felhasználónak tartom magam. Szeretem, mert közelebb áll az MS Excelhez, amit előtte kellett használnom, illetve követekezetesebb, egyértelműbb, kezelhetőbb, gyorsabb mint az SPSS Syntax-sza.<span id="more-182"></span></p>
<div>
<div>
<div>
<p><a href="http://xkcd.com/353/" target="_blank">Sok helyütt olvastam már</a> a Pythonról, de sosem próbáltam ki, mert csak zagyva bevezetőket és telepítési útmutatókat találtam, amiből semmit nem értettem. Nem vagyok programozó, szinte semmit nem tudok a számítógépekről. Azért használok Drupalt, mert egyszerű, kezelhető, de nem valószínű, hogy valaha is modulokat fejlesztenék hozzá. Tudom használni az R-ret, sőt, pár hete megírtam életem első S3 objektumát, és talán képes lennék rá, nem valószínű hogy készítek csomagot hozzá. De mégis, akkor hogy kezdtem el használni a Pythont?</p>
<p>Pár hete gyakornokoskodok egy cégnél, ahol azt mondták, érdemes beleásnom magamat, mert meg kell majd értenem a szkripteket. Ehhez segítséget is adtak: segítettek felrakni, beállítani a beállítandókat, természetesen nem tudnám megcsinálni újra. De végül ott ültem a gép előtt, előttem egy R-hez hasonló Python-ablak, és egy <a href="http://mek.oszk.hu/08400/08435/08435.pdf" target="_blank">jó könyv</a>, amiből tudok tanulni. Íme, amit az első pár fejezetből megtanultam:<br />
&#8211; a behúzás, tagolás fontos, nem használhatsz zárójeleket a blokkokhoz<br />
&#8211; az elsődleges promptba beletartozik a szóköz is: &#8220;&gt;&gt;&gt; &#8221;<br />
&#8211; az R-ben minden művelet függvény. A Python-ban kétféle függvény van: amelyiknek az argumentumai köré kell zárójel, és amelyiknek nem.<br />
&#8211; az egyetlen, hozzárendelésre szoláló jel a &#8220;=&#8221;<br />
&#8211; nem hívhatod elő az utolsó sor parancsot a kurzorral, de nem próbáltam ki, hogy a Page Up és Page Down gombokkal mit tudsz kezdeni.</p>
<p>Egyébként igen érdekes, és gép-közelibbnek tűnik mint az R, emiatt talán gyorsabb is.</p>
</div>
</div>
</div>
<p>Via: <a title="Elkezdtem a Pythont" href="http://atajti.hu/hu/content/elkezdtem-pythont" target="_blank">Elkezdtem a Pythont</a></p>
]]></content:encoded>
			<wfw:commentRss>/2013/04/13/elkezdtem-a-pythont/feed/</wfw:commentRss>
		<slash:comments>748</slash:comments>
		</item>
	</channel>
</rss>
